/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.int_watch.conf,v 5.0 2002/04/20 07:30:13 hardaker Exp $
 * hey.
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include <stdlib.h>
/*#include <string>
using namespace std;*/
#include "subagents.h"

//using namespace std;
#define MAX_STR_LEN 256
/*---------------------------------------------------------------------------------------------------*/

/* Make sure those next includes files are at this path, and that you've got the files */

#include "hiredis/hiredis.h"
#include "hiredis/async.h"
#include "hiredis/adapters/libevent.h"

/*---------------------------------------------------------------------------------------------------*/
//Redis connection
static redisContext *c;
redisContext **con = &c;

/*-----------------------------------------------------------------------------------*/
/*                                                                                   */
/* Every commented "DEBUGMSGTL" had exchanged with snmp_log, it's a way of debugging */
/*                                                                                   */
/*-----------------------------------------------------------------------------------*/


void connectToRedis(void)
{
    const char *hostname = "redis_db"; // Should be the name of the container where redis at
    int port = 6379; // Redis interacts at port 6379
    struct timeval timeout = { 1, 50000 }; // 1.5 seconds
    c = redisConnectWithTimeout(hostname, port, timeout); //Calling the connection function @hiredis/hiredis.c

    snmp_log(LOG_ERR, "Connecting to redis...\n");
    // Didn't connect to redis
    if(c == NULL || c->err)
    {
     	if(c) // Which means c->err
	{
            snmp_log(LOG_ERR, "connection error: %s\n", c->errstr);
            redisFree(c);
        }
        else // Which means c ==NULL
        {
            snmp_log(LOG_ERR, "connection error: can't allocate redis context\n");
        }
    }
    else // Connected successfully
    {
        snmp_log(LOG_ERR, "redis connection successful\n");
    }
}


void shutdownRedis(void)
{
    redisFree(c);
}

/*
 * the variable we want to tie an OID to.  The agent will handle all
 * GET and SET requests to this variable changing it's value as needed.
 */

static int myIntMibObject_value = 1;
static char myStringMibObject_value[MAX_STR_LEN] = "ALIVE";
static enum object_mode { myIntMibObject_mode, myStringMibObject_mode};
/** Initializes the sub_agent_test module */
void
init_subagents(void)
{
//                                      The whole oid as in the MY-MIB.txt, without the .0 at the end.
//                                                                     |
    static oid myIntMibObject_oid[] = { 1, 3, 6, 1, 4, 1, 8073, 1, 1, 4 };

    static oid myStringMibObject_oid[] = { 1, 3, 6, 1, 4, 1, 8073, 1, 1, 5 };

    // Registering the mib-handler, thus making the subagent able to maintain the myIntMibObject mib
    netsnmp_register_handler(
        netsnmp_create_handler_registration("myIntMibObject", handle_myIntMibObject,
                                            myIntMibObject_oid, OID_LENGTH(myIntMibObject_oid),
                                            HANDLER_CAN_RWRITE
        ));

    // Registering the mib-handler, thus making the subagent able to maintain the channel mib
    netsnmp_register_handler(
        netsnmp_create_handler_registration("myStringMibObject", handle_myStringMibObject,
                                            myStringMibObject_oid, OID_LENGTH(myStringMibObject_oid),
                                            HANDLER_CAN_RWRITE
        ));
}

int
handle_myIntMibObject(netsnmp_mib_handler *handler,
                               netsnmp_handler_registration *reginfo,
                               netsnmp_agent_request_info   *reqinfo,
                               netsnmp_request_info         *requests)
{
    int ret;
    /* we are never called for a GETNEXT if it's registered as a
       "instance", as it's "megically" handled for us. */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
    {
     	case MODE_GET: // snmpget
            GET_objects_redis(myIntMibObject_mode);
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                     &myIntMibObject_value,
                                     sizeof(myIntMibObject_value));
            break;

        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
             break;

        case MODE_SET_ACTION: // snmpset
            /* perform the value change here */

            if(requests->requestvb->type != ASN_INTEGER) // If it's not an integer
            {
             	netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_WRONGTYPE;
            }

            if(*requests->requestvb->val.integer < 0 || *requests->requestvb->val.integer > 100) // If myIntMibObject is not between 0-100
            {
             	netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                return SNMP_ERR_WRONGVALUE;
            }
            myIntMibObject_value = *requests->requestvb->val.integer; // Setting myIntMibObject_value as an preparation for the next function
            SET_objects_redis(myIntMibObject_mode); // Calling the fucntion which takes care of redis' setting
            break;

        default:
             /* we should never get here, so this is a really bad error */
             snmp_log(LOG_ERR, "unknown mode (%d) in handle_myIntMibObject\n", reqinfo->mode);
             return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_myStringMibObject(netsnmp_mib_handler *handler,
                               netsnmp_handler_registration *reginfo,
                               netsnmp_agent_request_info   *reqinfo,
                               netsnmp_request_info         *requests)
{
    int ret;
    /* we are never called for a GETNEXT if it's registered as a
       "instance", as it's "megically" handled for us. */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
    {
     	case MODE_GET: // snmpget
            GET_objects_redis(myStringMibObject_mode);
            snmp_set_var_typed_value(requests->requestvb,  ASN_OCTET_STR,
                                     myStringMibObject_value,
                                     sizeof(myStringMibObject_value));
            break;

        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
             break;

        case MODE_SET_ACTION: // snmpset
            /* perform the value change here */
            if(requests->requestvb->type != ASN_OCTET_STR) // If it's not a string
            {
             	netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_WRONGTYPE;
            }
            strncpy(myStringMibObject_value, requests->requestvb->val.string, MAX_STR_LEN);
	        myStringMibObject_value[MAX_STR_LEN - 1] = '\0';
            SET_objects_redis(myStringMibObject_mode); // Calling the fucntion which takes care of redis' setting
            break;

        default:
             /* we should never get here, so this is a really bad error */
             snmp_log(LOG_ERR, "unknown mode (%d) in handle_myStringMibObject\n", reqinfo->mode);
             return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}


void GET_objects_redis(int mode) // Manages snmpget
{   // mode: 0 - myIntMibObject
    //       1 - myStringMibObject
    //GET LOCAL MANAGE INFO
    //char next_command[MAX_STR_LEN];
    

    redisReply *reply;
    const char *line1 = "HGET";
    size_t len1 = strlen(line1);
    const char *line2;
    size_t len2;
    char *totalLine;
    if(mode == myIntMibObject_mode)
    {
        line2 = " myIntMibObjectField";
    }
    else if(mode == myStringMibObject_mode)
    {
        line2 = " myStringMibObjectField";
    }
    
    len2 = strlen(line2);
    totalLine = malloc(len1 + len2 + 1);
    if (!totalLine) abort();

    memcpy(totalLine,               line1, len1);
    memcpy(totalLine + len1,        line2, len2);
    totalLine[len1 + len2] = '\0';

    // Normal redis get command, getting xObjectField from redis server
    reply = redisCommand(c, totalLine);
    snmp_log(LOG_ERR, "reply  snmpget: %s\n", reply->str);

    if(mode == myIntMibObject_mode)
    { myIntMibObject_value = atoi(reply->str); }
    else
    { strncpy(myStringMibObject_value, reply->str, MAX_STR_LEN);
      myStringMibObject_value[MAX_STR_LEN - 1] = '\0'; }
    freeReplyObject(reply);
}

void SET_objects_redis(int mode)
{
    redisReply *reply;
    if(mode == myIntMibObject_mode)
    {
        // Normal redis set command, setting myIntMibObjectField from redis server
        reply = (redisReply*)(redisCommand(*con, "HSET myIntMibObjectField %d",  myIntMibObject_value));
    }
    else
    {
        // Normal redis set command, setting myStringMibObjectField from redis server
        reply = (redisReply*)(redisCommand(*con, "HSET myStringMibObjectField %s", myStringMibObject_value));
    }

    if(reply->type == REDIS_REPLY_ERROR)
    {
        snmp_log(LOG_ERR, "SET error: %s\n", reply->str);
    }
    freeReplyObject(reply);
}

